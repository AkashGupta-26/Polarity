# Polarity  
A fully functional chess engine built in C/C++

I am trying to build a modular engine for easy and efficient debugging, so the project is split into several files. The main files are:
- `engine.cpp` - The main engine file.
- `moves.h` - Contains the move generation logic.
- `precalculated_move_tables.h` - Contains the precalculated move tables.
- `board.h` - Contains the board representation and logic.
- `constants.h` - Contains the constants used in the engine.

---

## Board & Piece Representation

The board is represented as a 64-bit integer, where each bit represents a square on the board. This approach is widely known as the bitboard approach, as it allows for easy move generation. 

The pieces are represented as follows: 
| Piece           | Symbol | Value |
|------------------|--------|--------|
| White Pawn       | `P`    | 0      |
| White Knight     | `N`    | 1      |
| White Bishop     | `B`    | 2      |
| White Rook       | `R`    | 3      |
| White Queen      | `Q`    | 4      |
| White King       | `K`    | 5      |
| Black Pawn       | `p`    | 6      |
| Black Knight     | `n`    | 7      |
| Black Bishop     | `b`    | 8      |
| Black Rook       | `r`    | 9      |
| Black Queen      | `q`    | 10     |
| Black King       | `k`    | 11     |


Thus, the entire board can be represented with 12 `bitboards`, one for each piece type. Four more bitboards are used to represent:
- The white pieces
- The black pieces
- The occupied squares
- The empty squares  

These are maintained to avoid runtime calculations.

Additionally, 3 integers are used to represent:
- The castling rights
- The en passant square
- The side to move

The squares are enumerated from 0 to 63, starting from the a1 square (0) to the h8 square (63).

---

## Move Generation

The move generation is inspired from the [YouTube Series by Chess Programming](https://www.youtube.com/playlist?list=PLmN0neTso3Jxh8ZIylk74JpwfiWNI76Cs). The move generation is done using bitboards, which allows for fast move generation and easy manipulation of the board.

For example, all pawn pushes can be generated by simply bitwise shifting the white pawn bitboard one square up and the black pawn bitboard one square down, and performing a bitwise AND with the empty squares. Double pawn pushes can be generated by shifting the white pawns from the previous operation and then performing a bitwise AND with the empty squares once again.

Knight and King moves are precalculated using a lookup table, while Bishop, Rook, and Queen moves are generated using magic bitboards.

I am using **pseudo-legal** move generation, which means that the moves generated are not checked for legality (e.g., whether the king is in check). This is done to speed up the move generation process. The legality of a move is checked in the `makeMove` function, which is called when making a move on the board.


### Take Back Implementation

I am currently using a simple take back implementation that uses function stack memory to store the previous board state. I am not informed the other techniques used, and thus I believe this will allow me to only store a single state in the main loop, unless I use a stack to store the previous states. As of now I was more focused on the move generation and evaluation, so I will implement a more robust take back implementation later as search would never want to take back more than one move at a time in a single function call. 

### Legal Move Generation

The `makeMove` function performs the move on board, updates the board state and checks if the king was left in check after the move. If the king is in check, the move is undone and `0` is returned. Otherwise, the move is made and `1` is returned.

**Currently the move generator is able to traverse around 70M nodes per second. I feel this is good enough for our current expectations from the engine. I would expect the Search and Evaluation to be good enough that a few million nodes up or down may be of a lesser significance.**

---
## Evaluation

We are using a tapered evaluation scheme based on `PeSTO` tables, with middlegame and endgame weights. The evaluation is done using a simple piece-square table, which is a common approach in chess engines. The piece-square table is used to evaluate the position of the pieces on the board, and the weights are used to adjust the evaluation based on the phase of the game (middlegame or endgame). We are also using file masks for detecting passed pawns, and a simple king safety evaluation based on the number of pawns around the king. 

For endgame checkmates, we are using a `Mop-Up Evaluation`, which encourages the king to close down on the enemy king towards the edges and corners of the board and restricts it's movement. This is done by calculating a simple Manhattan distance between the two kings and adjusting the evaluation based on the distance. This helps for quickly checkmating the opponent in finding Rook and Bishop checkmates.

---
## Search

I am using a minimax search with alpha-beta pruning. The search is done using a simple iterative deepening approach, which allows for a quick response time and a good search depth. The search is also using a simple transposition table to store previously searched positions, which helps to avoid redundant searches.

Multiple techniques such as `Null Move Pruning`, `Late Move Reductions`, and `Quiescence Search` are implemented to improve the search efficiency. The search is also using a simple move ordering technique, which helps to improve the search efficiency by searching the best moves first. Move ordering is done using `Most Valuable Victim - Least Valuable Aggressor` (MVV-LVA) heuristic. We are also storing History Moves, Killer Moves and Principal Variation (PV) moves to improve the move ordering.

- `Quiescence Search` is used to search for captures only, which helps to avoid the horizon effect and allows for a more accurate evaluation.
- `Move Ordering` is done using the MVV-LVA heuristic, which orders the moves based on the value of the captured piece and the value of the attacking piece. This helps to improve the search efficiency by searching the most promising moves first. This may seem to result in a loss of tactical awareness and may seem to avoid variations that involve sacrifices. However, the engine is able to search deeper and will ultimately find the tactics most of the time. To mitigate this, we are also using a simple history heuristic along with killer moves to order the moves based on their previous success.
- Along with this, the `Principal Variation` (PV) search is used to store the best moves found so far, which helps to improve the search efficiency by searching the best moves first.
- `Transposition Tables` are used to store previously searched positions, which helps to avoid redundant searches and improve the search efficiency. The transposition table is implemented using a simple hash table, which stores the position and the evaluation of the position.
- `Null Move Pruning` is basically evaluating positions after giving your opponent a free move. If the position is still good for us, we may conclude that the move chosen earlier in the tree was not as good and thus we can prune the search tree as our opponent won't chose that move either.
- `Late Move Reductions` assume that our move ordering is good enough that we can reduce the search depth for moves that are not in the top few moves. This helps to improve the search efficiency by reducing the search depth for less promising moves.
- We are also using `aspiration windows`, which are narrow windows around the expected value of a position. This helps to reduce the search space and improve the search efficiency as we can prune so many moves. However, if the resulting evaluation was still outside bounds, we will have to re-search the position with a wider window. This follows the idea that proving a move is bad is generally faster than proving a move is good, and thus we can quickly prune the search space, but obviously they may lead to redundant searches.

---
## Version History

### Polarity V10
- Added check detection for move ordering, performs worse than V9.
- -40 elo points than V7.
- reverted to V9 for now.

### Polarity V9
- Allowed Checks to be processed in Quiescence Search.
- Added back Mobility Bonus for minor pieces in endgame with lesser weights.
- +30 Elo points than V7.

### Polarity V8
- Added Minor Piece Endgame Helper for Bishops.
- Removed mobility bonus for minor pieces in endgame.
- -40 Elo points than V7.

### Polarity V7
- Added Insufficient Material Detection.
- +30 Elo points than V6.

### Polarity V6
- Added Mobility Bonus for all pieces to encourage piece activity.
- Added King Shield Bonus
- Transposition Table now clears only on UCI new game command.
- +70 Elo points than V5.

### Polarity V5
- Added Best Move history and ordering in Transposition Table.
- +40 Elo points than V4.

### Polarity V4
- Added Tapered evaluation.
- MopUp evaluation for endgame checkmates.
- +50 Elo points than V3.

### Polarity V3
- Added PeSTO evaluation tables.
- +80 Elo points than V2.

### Polarity V2
- Added Passed Pawn bonus and Isolated Pawn penalty.
- +30 Elo points than V1.

### Polarity V1
- Initial release with basic evaluation and search.
- Evaluation based on estimated piece values and piece-square tables.

---
## References

- [Chess Programming Wiki](https://www.chessprogramming.org/Main_Page)
- [Sebastian Lague's Chess Project](https://www.youtube.com/watch?v=_vqlIPDR2TU)
- [YouTube Series by Chess Programming](https://www.youtube.com/playlist?list=PLmN0neTso3Jxh8ZIylk74JpwfiWNI76Cs)
- [Blog](https://ameye.dev/notes/chess-engine/)
