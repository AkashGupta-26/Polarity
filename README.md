# Polarity  
A fully functional chess engine built in C/C++

The move generator is based heavily on the [YouTube Series by Chess Programming](https://www.youtube.com/playlist?list=PLmN0neTso3Jxh8ZIylk74JpwfiWNI76Cs). It's an excellent series and highly recommended.

I have decided to use a more modular approach to the code rather than the didactic approach in the series, so the engine is split into several files. The main files are:
- `engine.cpp` - The main engine file.
- `moves.h` - Contains the move generation logic.
- `precalculated_move_tables.h` - Contains the precalculated move tables.
- `board.h` - Contains the board representation and logic.
- `constants.h` - Contains the constants used in the engine.

---

## Board & Piece Representation

The board is represented as a 64-bit integer, where each bit represents a square on the board. This approach is widely known as the bitboard approach, as it allows for easy move generation. 

The pieces are represented as follows: 
| Piece           | Symbol | Value |
|------------------|--------|--------|
| White Pawn       | `P`    | 0      |
| White Knight     | `N`    | 1      |
| White Bishop     | `B`    | 2      |
| White Rook       | `R`    | 3      |
| White Queen      | `Q`    | 4      |
| White King       | `K`    | 5      |
| Black Pawn       | `p`    | 6      |
| Black Knight     | `n`    | 7      |
| Black Bishop     | `b`    | 8      |
| Black Rook       | `r`    | 9      |
| Black Queen      | `q`    | 10     |
| Black King       | `k`    | 11     |


Thus, the entire board can be represented with 12 `bitboards`, one for each piece type. Four more bitboards are used to represent:
- The white pieces
- The black pieces
- The occupied squares
- The empty squares  

These are maintained to avoid runtime calculations.

Additionally, 3 integers are used to represent:
- The castling rights
- The en passant square
- The side to move

The squares are enumerated from 0 to 63, starting from the a1 square (0) to the h8 square (63).

---

## Move Generation

The move generation is based on the [YouTube Series by Chess Programming](https://www.youtube.com/playlist?list=PLmN0neTso3Jxh8ZIylk74JpwfiWNI76Cs). The move generation is done using bitboards, which allows for fast move generation and easy manipulation of the board.

For example, all pawn pushes can be generated by simply bitwise shifting the white pawn bitboard one square up and the black pawn bitboard one square down, and performing a bitwise AND with the empty squares. Double pawn pushes can be generated by shifting the white pawns from the previous operation and then performing a bitwise AND with the empty squares once again.

Knight and King moves are precalculated using a lookup table, while Bishop, Rook, and Queen moves are generated using magic bitboards.

I am using **pseudo-legal** move generation, which means that the moves generated are not checked for legality (e.g., whether the king is in check). This is done to speed up the move generation process. The legality of


### Take Back Implementation

I am currently using a simple take back implementation that uses function stack memory to store the previous board state. I am not informed the other techniques used, and thus I believe this will allow me to only store a single state in the main loop, unless I use a stack to store the previous states. As of now I was more focused on the move generation and evaluation, so I will implement a more robust take back implementation later as search would never want to take back more than one move at a time in a single function call. 

### Legal Move Generation

The `makeMove` function performs the move on board, updates the board state and checks if the king was left in check after the move. If the king is in check, the move is undone and `0` is returned. Otherwise, the move is made and `1` is returned.

**Currently the move generator is able to traverse around 70M nodes per second. I feel this is good enough for our current expectations from the engine. I would expect the Search and Evaluation to be good enough that a few million nodes up or down may be of a lesser significance.**